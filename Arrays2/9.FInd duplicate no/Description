DSA 10/ Leetcode 287: Find the duplicate no
Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.
There is only one repeated number in nums, return this repeated number.
You must solve the problem without modifying the array nums and using only constant extra space.


Given an array of n+1 integers, with all elements in the range [1, n] (both inclusive, I mean anybody knows square brackets are notation for both inclusive, but still..)
we need to find which is the one number among [1,n] that repeats in the array. There has to be one that repeats due to pigeonhole principle. The number could repeat
multiple times, all the nos from 1 to n need not be in the list, but the only thing is that there is only one number that repeats in the whole list. 

Solution:-
1)Brute force(No extra space, but O(n2) time complexity)
The first approach is the simple brute force approach where I take one element i to iterate through the list from 0th index to (n-2)th index. In the inner loop, I 
iterate j from i+1 to n-1th index, and if nums[i] == nums[j], return nums[i](or nums[j], both are the same). This approach uses no extra space, but O(n2) time complexity

class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        for i in range(len(nums)-1):
            for j in range(i+1, len(nums)):
                if nums[i] == nums[j]:
                    return nums[i]
                    break
This doesn't pass many test cases due to exceeding time limit.

2) High space approach(Extra spacem but O(n) time complexity):

Here, I create a dictionary or a hash map frequencies, with the number being the key and the frequency of occurences the corresponding value. After addding all items
to the dictionary, we traverse the dictionary to check if any element's frequency is greater than 1, and if yes, we return that element.

class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        frequency = {}
        for i in nums:
            if i in frequency:
                frequency[i] = frequency[i] + 1
            else:
                frequency[i] = 1
        for i in frequency:
            if frequency[i] > 1:
                return i

This uses O(n) extra space, so it can be problematic with large arrays, although it does pass all test cases. It has time complexity O(n) to traverse array, enter
in dictionary, and another O(n) to later traverse the dictionary and check the frequency. Now that I think about it,  I feel we can finish it in tbe first loop itself,
like if i in frequency, the element repeats and therefore, that is the element and we can return it then and there.

class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        frequency = {}
        for i in nums:
            if i in frequency:
                frequency[i] = frequency[i] + 1
                return i
            else:
                frequency[i] = 1
Well I guess I can just use sets instead of dictionary for that. I am not writing a separate code for it also lol. How many should I keep on writing lol.

3) Now, coming to the optimal solution,
