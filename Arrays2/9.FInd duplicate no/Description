DSA 10/ Leetcode 287: Find the duplicate no
Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.
There is only one repeated number in nums, return this repeated number.
You must solve the problem without modifying the array nums and using only constant extra space.


Given an array of n+1 integers, with all elements in the range [1, n] (both inclusive, I mean anybody knows square brackets are notation for both inclusive, but still..)
we need to find which is the one number among [1,n] that repeats in the array. There has to be one that repeats due to pigeonhole principle. The number could repeat
multiple times, all the nos from 1 to n need not be in the list, but the only thing is that there is only one number that repeats in the whole list. 

Solution:-
1)Brute force(No extra space, but O(n2) time complexity)
The first approach is the simple brute force approach where I take one element i to iterate through the list from 0th index to (n-2)th index. In the inner loop, I 
iterate j from i+1 to n-1th index, and if nums[i] == nums[j], return nums[i](or nums[j], both are the same). This approach uses no extra space, but O(n2) time complexity

class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        for i in range(len(nums)-1):
            for j in range(i+1, len(nums)):
                if nums[i] == nums[j]:
                    return nums[i]
                    break
This doesn't pass many test cases due to exceeding time limit.

2) High space approach(Extra spacem but O(n) time complexity):

Here, I create a dictionary or a hash map frequencies, with the number being the key and the frequency of occurences the corresponding value. After addding all items
to the dictionary, we traverse the dictionary to check if any element's frequency is greater than 1, and if yes, we return that element.

class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        frequency = {}
        for i in nums:
            if i in frequency:
                frequency[i] = frequency[i] + 1
            else:
                frequency[i] = 1
        for i in frequency:
            if frequency[i] > 1:
                return i

This uses O(n) extra space, so it can be problematic with large arrays, although it does pass all test cases. It has time complexity O(n) to traverse array, enter
in dictionary, and another O(n) to later traverse the dictionary and check the frequency. Now that I think about it,  I feel we can finish it in tbe first loop itself,
like if i in frequency, the element repeats and therefore, that is the element and we can return it then and there.

class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        frequency = {}
        for i in nums:
            if i in frequency:
                frequency[i] = frequency[i] + 1
                return i
            else:
                frequency[i] = 1
Well I guess I can just use sets instead of dictionary for that. I am not writing a separate code for it also lol. How many should I keep on writing lol.

3)Coming to another approach, which takes O(nlogn) time complexity, we first sort the array and then we traverse through the array and check if nums[i] == nums[i+1]
  for any i. If yes, we return nums[i] as that is the repeating number. Otherwise, it traverses through the array without returning anything and returns -1.

  class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        nums.sort()
        for i in range(len(nums)-1):
            if nums[i] == nums[i+1]:
                return nums[i]
        return -1

4) Now, coming to the optimal solution, we use Floyd's tortoise hare algorithm. This algorithm basically involves seeing this list as a linked list, with each entry
   'pointing' to that number th index. ie 3 points to nums[3], if nums[3] = 1, then that points to nums[1] and so on. 

Now, based on this, we create 2 pointers, slow and fast. Both of them are initially set to nums[0]. Both these pointers move in the linked list. The slow pointer
moves one step at a time, while the fast pointer moves 2 steps at a time. If there is a cycle(which there will be as there is compulsorily a repeating number as
given in the question, and thus, the second instance and the further instances(if there) for that particular number will point to the same entry that some other
element has pointed to before itself, leading to a cycle), the slow and fast pointers will surely meet. The reason is, imagine 2 people are running around a circular
ground, one person running twice as fast as the other person. Now, the faster person will surely lap around and meet the slower person at a particular point, as
it is a circle and they have to keep running around the same path. As Cap said to Falcon, "On your left".  But if it was a straight path Cap and Sam(Falcon) were 
running on, Cap would have kept going farther and farther away from Sam, and the distance would have only increased among them and there would be no 'On your left'.
Similarly, if there was no cycle, the fast pointer would cross the linked list and reach null. But since there is, it will circle around the same path and hence,
they will meet.

Now, after they meet we set the slow pointer again to nums[0]. We don't change the fast pointer and let it be in the same point where the slow and the fast pointer
had earlier met in the first phase. Now, we move both the slow and the fast pointer one step at a time, untill slow = fast. The number where slow = fast is the no
that repeats.

class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        slow = nums[0]
        fast = nums[0]
        while True:
            slow = nums[slow]
            fast = nums[nums[fast]]
            if slow == fast:
                break
        slow = nums[0]
        while slow != fast:
            slow = nums[slow]
            fast = nums[fast]
        return slow
